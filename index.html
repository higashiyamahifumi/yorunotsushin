<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YORU NO TSUSHIN</title>

  <!-- Google Font (SF / machine vibe) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg0:#05070c;
      --bg1:#070b12;
      --shell0:#07101e;
      --shell1:#06101a;
      --edge:#13233a;

      --text:#d7deea;
      --ind:#9fe3b6;

      --shadow: rgba(0,0,0,.70);
    }
    *{box-sizing:border-box}
    html, body { height:100%; }
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:
        radial-gradient(900px 540px at 55% 10%, rgba(255,255,255,.05), transparent 60%),
        radial-gradient(1000px 700px at 40% 120%, rgba(255,255,255,.03), transparent 58%),
        linear-gradient(180deg, var(--bg1) 0%, var(--bg0) 100%);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      letter-spacing:.45px;
      color: var(--text);
      overscroll-behavior: none;
    }

    .wrap{width:min(860px, 94vw); padding:22px;}
    .unit{
      background: linear-gradient(180deg, var(--shell0) 0%, var(--shell1) 100%);
      border: 1px solid var(--edge);
      border-radius: 16px;
      box-shadow:
        0 22px 60px var(--shadow),
        inset 0 1px 0 rgba(255,255,255,.05);
      overflow:hidden;
    }

    .top{
      padding:16px;
      border-bottom:1px solid rgba(19,35,58,.9);
      background:
        linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,0) 70%),
        linear-gradient(90deg, rgba(0,0,0,.25), transparent 45%, rgba(0,0,0,.35));
    }

    .title{
      font-family: "Orbitron", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:16px;
      font-weight:900;
      text-transform:uppercase;
      letter-spacing:4px;
      color: rgba(215,222,234,.92);
      user-select:none;
      -webkit-user-select:none;
    }

    .mid{
      padding:16px;
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.24));
    }

    .padPlate{
      width:100%;
      height:min(62vh, 520px);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.05);
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.22));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
      position:relative;
      overflow:hidden;

      touch-action:none;
      -webkit-tap-highlight-color: transparent;
    }
    .padPlate::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        linear-gradient(rgba(255,255,255,.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,.06) 1px, transparent 1px);
      background-size: 16px 16px;
      opacity:.18;
      pointer-events:none;
    }
    .vline{
      position:absolute;
      left:50%; top:0;
      width:1px; height:100%;
      background: rgba(255,255,255,.08);
      transform:translateX(-50%);
      pointer-events:none;
    }
    .hline{
      position:absolute;
      left:0; top:50%;
      width:100%; height:1px;
      background: rgba(255,255,255,.08);
      transform:translateY(-50%);
      pointer-events:none;
    }

    .dot{
      position:absolute;
      width:14px; height:14px;
      border-radius:999px;
      background: rgba(159,227,182,.70);
      border:1px solid rgba(159,227,182,.35);
      box-shadow: 0 0 10px rgba(159,227,182,.18);
      transform: translate(-50%,-50%);
      pointer-events:none;
      opacity:.9;
    }
    .dot.off{
      opacity:.25;
      background: rgba(159,227,182,.18);
      box-shadow:none;
    }

    .padHit{
      position:absolute;
      inset:0;
      display:block;
      touch-action:none;
      -webkit-tap-highlight-color: transparent;
      background: transparent;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="unit">
      <div class="top">
        <div class="title">YORU NO TSUSHIN</div>
      </div>

      <div class="mid">
        <div class="padPlate" id="pad">
          <div class="vline"></div>
          <div class="hline"></div>
          <div class="dot off" id="dot"></div>
          <div class="padHit" id="hit" aria-label="XY pad"></div>
        </div>
      </div>
    </div>
  </div>

<script>
/*
  XY mapping (your latest spec):
  - Y (up/down) = pitch: top high, bottom low
  - X (left/right) = interval speed: RIGHT fast, LEFT slow

  Sound:
  - On press: random pick from Fmaj7(9): F A C E G
  - Busy-tone gating by LFO (square -> shaper -> gate.gain) for stable mobile timing
  - "Bug": about 1/15 chance per press to output white noise (only while held)
*/

let ctx, master, gate;
let osc, oscGain;
let noiseGain, noiseBuffer, noiseSrc = null;

let lfo, shaper, lfoDepth;
let iosUnlocked = false;

const pad = document.getElementById("pad");
const hit = document.getElementById("hit");
const dot = document.getElementById("dot");

/* interval range (ms): RIGHT=FAST, LEFT=SLOW */
const MIN_MS = 160; // fastest
const MAX_MS = 900; // slowest

/* Fmaj7(9): F A C E G (MID register) */
const MID = [
  { name: "F", hz: 349.228 },
  { name: "A", hz: 440.000 },
  { name: "C", hz: 523.251 },
  { name: "E", hz: 659.255 },
  { name: "G", hz: 783.991 },
];

let current = MID[0];
let x01 = 0.5; // 0..1
let y01 = 0.5; // 0..1
let holding = false;
let bugMode = false;

function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function pickRandomNote(){ return MID[(Math.random() * MID.length) | 0]; }

/* Y = pitch : top high, bottom low (mult 0.5..2.0) */
function yToMult(y){
  // y=0(top)->2.0, y=1(bottom)->0.5
  return 2.0 - 1.5 * y;
}

/* X = interval : right fast, left slow */
function xToMs(x){
  // x=0(left)->MAX_MS, x=1(right)->MIN_MS
  return MAX_MS - (MAX_MS - MIN_MS) * x;
}

/* LFO freq so ON=ms, OFF=ms => full period=2ms => freq=500/ms */
function msToLfoHz(ms){ return 500 / ms; }

function ensureAudio(){
  if (ctx) return;
  ctx = new (window.AudioContext || window.webkitAudioContext)();

  master = ctx.createGain();
  master.gain.value = 0.0;

  gate = ctx.createGain();
  gate.gain.value = 0.0;

  // source selector gains
  oscGain = ctx.createGain();
  oscGain.gain.value = 1.0;

  noiseGain = ctx.createGain();
  noiseGain.gain.value = 0.0;

  // oscillator (always running)
  osc = ctx.createOscillator();
  osc.type = "sine";
  osc.frequency.value = current.hz;
  osc.connect(oscGain);

  // mix -> gate -> master -> out
  oscGain.connect(gate);
  noiseGain.connect(gate);
  gate.connect(master);
  master.connect(ctx.destination);

  osc.start();

  // prebuild white noise buffer (2 seconds loop)
  const len = ctx.sampleRate * 2;
  noiseBuffer = ctx.createBuffer(1, len, ctx.sampleRate);
  const data = noiseBuffer.getChannelData(0);
  for (let i = 0; i < len; i++){
    data[i] = (Math.random() * 2 - 1);
  }

  // LFO gate (stable on mobile)
  lfo = ctx.createOscillator();
  lfo.type = "square";
  lfo.frequency.value = msToLfoHz(xToMs(x01));

  shaper = ctx.createWaveShaper();
  const N = 1024;
  const curve = new Float32Array(N);
  for (let i=0;i<N;i++){
    const x = (i/(N-1))*2-1;
    curve[i] = x >= 0 ? 1 : 0;
  }
  shaper.curve = curve;
  shaper.oversample = "4x";

  lfoDepth = ctx.createGain();
  lfoDepth.gain.value = 0.0; // off until holding

  lfo.connect(shaper);
  shaper.connect(lfoDepth);
  lfoDepth.connect(gate.gain);

  lfo.start();
}

function unlockIOSOnce(){
  if (!ctx || iosUnlocked) return;
  try{
    const buffer = ctx.createBuffer(1, 1, ctx.sampleRate);
    const src = ctx.createBufferSource();
    src.buffer = buffer;
    src.connect(ctx.destination);
    src.start(0);
    src.stop(0.01);
    iosUnlocked = true;
  }catch(e){}
}

function ramp(param, value, t=0.02){
  const now = ctx.currentTime;
  param.cancelScheduledValues(now);
  param.setValueAtTime(param.value, now);
  param.linearRampToValueAtTime(value, now + t);
}

function applyXY(){
  const r = pad.getBoundingClientRect();
  dot.style.left = (x01 * r.width) + "px";
  dot.style.top  = (y01 * r.height) + "px";

  if (!ctx || !osc || !lfo) return;

  const mult = yToMult(y01); // pitch from Y
  const ms = xToMs(x01);     // interval from X

  // oscillator pitch (ignored if bugMode noise is active, but harmless)
  const det = 1 + (Math.random()*0.002 - 0.001);
  osc.frequency.value = (current.hz * mult) * det;

  // gate speed
  lfo.frequency.value = msToLfoHz(ms);
}

function startNoiseIfNeeded(){
  if (!ctx) return;
  if (!noiseSrc){
    noiseSrc = ctx.createBufferSource();
    noiseSrc.buffer = noiseBuffer;
    noiseSrc.loop = true;
    noiseSrc.connect(noiseGain);
    noiseSrc.start();
  }
}

function stopNoiseIfNeeded(){
  if (noiseSrc){
    try{ noiseSrc.stop(); }catch(e){}
    try{ noiseSrc.disconnect(); }catch(e){}
    noiseSrc = null;
  }
}

function startAudioGesture(){
  ensureAudio();
  unlockIOSOnce();

  ctx.resume().then(() => {
    if (ctx.state !== "running") return;

    holding = true;
    dot.classList.remove("off");

    // choose note on each press
    current = pickRandomNote();

    // 1/15 "bug" chance
    bugMode = (Math.random() < (1/15));

    // select source
    if (bugMode){
      startNoiseIfNeeded();
      ramp(oscGain.gain, 0.0, 0.02);
      ramp(noiseGain.gain, 1.0, 0.02);
    } else {
      stopNoiseIfNeeded();
      ramp(noiseGain.gain, 0.0, 0.02);
      ramp(oscGain.gain, 1.0, 0.02);
    }

    applyXY();

    // turn on gating + volume
    ramp(lfoDepth.gain, 1.0, 0.02);
    ramp(master.gain, 0.16, 0.02);
  }).catch(()=>{});
}

function stop(){
  holding = false;
  dot.classList.add("off");
  if (!ctx) return;

  // fade out
  ramp(lfoDepth.gain, 0.0, 0.03);
  ramp(master.gain, 0.0, 0.05);

  // stop noise after fade so it doesnâ€™t click
  setTimeout(() => {
    if (!holding) stopNoiseIfNeeded();
  }, 120);
}

function updateFromClientXY(clientX, clientY){
  const r = pad.getBoundingClientRect();
  x01 = clamp01((clientX - r.left) / r.width);
  y01 = clamp01((clientY - r.top) / r.height);
  applyXY();
}

/* pointer + touch */
let pid = null;

hit.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  pid = e.pointerId;
  try { hit.setPointerCapture(pid); } catch(_){}
  updateFromClientXY(e.clientX, e.clientY);
  startAudioGesture();
}, {passive:false});

hit.addEventListener("pointermove", (e) => {
  if (!holding) return;
  if (pid !== null && e.pointerId !== pid) return;
  e.preventDefault();
  updateFromClientXY(e.clientX, e.clientY);
}, {passive:false});

hit.addEventListener("pointerup", (e) => {
  if (pid !== null && e.pointerId !== pid) return;
  e.preventDefault();
  pid = null;
  stop();
}, {passive:false});

hit.addEventListener("pointercancel", (e) => {
  e.preventDefault();
  pid = null;
  stop();
}, {passive:false});

hit.addEventListener("touchstart", (e) => {
  e.preventDefault();
  const t = e.touches[0];
  if (!t) return;
  updateFromClientXY(t.clientX, t.clientY);
  startAudioGesture();
}, {passive:false});

hit.addEventListener("touchmove", (e) => {
  if (!holding) return;
  e.preventDefault();
  const t = e.touches[0];
  if (!t) return;
  updateFromClientXY(t.clientX, t.clientY);
}, {passive:false});

hit.addEventListener("touchend", (e) => { e.preventDefault(); stop(); }, {passive:false});
hit.addEventListener("touchcancel", (e) => { e.preventDefault(); stop(); }, {passive:false});

window.addEventListener("blur", stop);
document.addEventListener("visibilitychange", () => { if (document.hidden) stop(); });

// initial dot
applyXY();
</script>
</body>
</html>
