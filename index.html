<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>yoru no tsushin</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@200;300;400&display=swap" rel="stylesheet">

  <style>
    :root{
      --grid: 22px;                    /* square grid size */
      --bg: #050724;                   /* solid dark blue */

      --paper:#b9bcc4;                 /* matte gray panel */
      --paper2:#aeb2bc;

      --line: rgba(0,0,255,.16);       /* grid lines */
      --lineStrong: rgba(0,0,255,.92); /* border */
      --shadow: rgba(0,0,0,.62);

      --txt: rgba(255,255,255,.22);    /* ghost title */
    }

    *{box-sizing:border-box}
    html,body{height:100%}

    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background: var(--bg);
      overscroll-behavior:none;
    }

    .padWrap{
      width:min(92vw, 900px);
      height:min(78vh, 640px);
      display:grid;
      place-items:center;
    }

    .pad{
      width:100%;
      height:100%;
      border-radius:12px;
      background:
        linear-gradient(180deg, rgba(185,188,196,.92), rgba(174,178,188,.90));
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.40),
        inset 0 -1px 0 rgba(0,0,0,.18),
        0 26px 90px var(--shadow);
      border:2px solid var(--lineStrong);
      position:relative;
      overflow:hidden;
      touch-action:none;
      -webkit-tap-highlight-color: transparent;
    }

    /* square symmetric grid ONLY (no center cross) */
    .pad::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        repeating-linear-gradient(0deg,  var(--line) 0 1px, transparent 1px var(--grid)),
        repeating-linear-gradient(90deg, var(--line) 0 1px, transparent 1px var(--grid));
      pointer-events:none;
      opacity:1;
    }

    /* subtle tint slab */
    .slab{
      position:absolute;
      left:-80px;
      bottom:-180px;
      width:130%;
      height:130%;
      pointer-events:none;
      opacity:.10;
      transform: skewX(-10deg);
      background:
        radial-gradient(closest-side at 30% 70%, rgba(0,0,255,.75), transparent 62%),
        radial-gradient(closest-side at 55% 75%, rgba(0,0,255,.55), transparent 64%),
        radial-gradient(closest-side at 70% 40%, rgba(0,0,255,.45), transparent 60%);
      mix-blend-mode:multiply;
      filter: blur(.2px);
    }

    .ghost{
      position:absolute;
      top:12px;
      right:14px;
      font-family:"Oxanium", ui-monospace, monospace;
      font-weight:200;
      letter-spacing:3.5px;
      text-transform: lowercase;
      font-size:15px;
      color: var(--txt);
      user-select:none;
      -webkit-user-select:none;
      pointer-events:none;
      mix-blend-mode: screen;
    }

    .dot{
      position:absolute;
      width:12px; height:12px;
      border-radius:999px;
      background: rgba(0,0,255,.92);
      box-shadow: 0 0 16px rgba(0,0,255,.25);
      border:1px solid rgba(255,255,255,.38);
      transform: translate(-50%,-50%);
      pointer-events:none;
      opacity:.95;
    }
    .dot.off{
      opacity:.30;
      background: rgba(0,0,255,.35);
      box-shadow:none;
    }

    .hit{
      position:absolute;
      inset:0;
      display:block;
      background: transparent;
      touch-action:none;
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>

<body>
  <div class="padWrap" id="wrap">
    <div class="pad" id="pad" aria-label="xy pad">
      <div class="slab" aria-hidden="true"></div>
      <div class="ghost" aria-hidden="true">yoru no tsushin</div>
      <div class="dot off" id="dot"></div>
      <div class="hit" id="hit"></div>
    </div>
  </div>

<script>
/* =========================================================
   YORU NO TSUSHIN — WebAudio XY pad
   - Hold to transmit
   - Y: pitch (up=high)
   - X: interval speed (right=fast)
   - Normal: sine busy-tone on random note (F A C E G)
   - Bug A: 1/15 noise mode (3 types) while held @20%
   - Bug B: 1/12 “SF UI beep” one-shot (5 types) @20%
========================================================= */

let ctx, master, gate;
let osc, oscGain;
let lfo, shaper, lfoDepth;

let noiseGain;
let noiseSrc = null;
let iosUnlocked = false;

let glitchBus;

const pad = document.getElementById("pad");
const hit = document.getElementById("hit");
const dot = document.getElementById("dot");

/* timing */
const MIN_MS = 160;
const MAX_MS = 900;

/* levels */
const MASTER_LEVEL = 0.096;  // overall level
const BUG_LEVEL = 0.20;      // glitch/noise one-shots bus

/* probabilities */
const NOISE_PROB  = 1/15;
const GLITCH_PROB = 1/12;

/* chord tones: Fmaj7(9) = F A C E G */
const MID = [
  { hz: 349.228 }, // F4
  { hz: 440.000 }, // A4
  { hz: 523.251 }, // C5
  { hz: 659.255 }, // E5
  { hz: 783.991 }, // G5
];

let current = MID[0];
let x01 = 0.5;
let y01 = 0.5;
let holding = false;

function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function pickRandomNote(){ return MID[(Math.random() * MID.length) | 0]; }

function yToMult(y){ return 2.0 - 1.5 * y; }                 // top high
function xToMs(x){ return MAX_MS - (MAX_MS - MIN_MS) * x; }  // right fast
function msToLfoHz(ms){ return 500 / ms; }                   // 50% duty-ish

function ensureAudio(){
  if (ctx) return;
  ctx = new (window.AudioContext || window.webkitAudioContext)();

  master = ctx.createGain();
  master.gain.value = 0.0;
  master.connect(ctx.destination);

  gate = ctx.createGain();
  gate.gain.value = 0.0;

  oscGain = ctx.createGain();
  oscGain.gain.value = 1.0;

  noiseGain = ctx.createGain();
  noiseGain.gain.value = 0.0;

  glitchBus = ctx.createGain();
  glitchBus.gain.value = BUG_LEVEL;
  glitchBus.connect(master);

  /* main oscillator */
  osc = ctx.createOscillator();
  osc.type = "sine";
  osc.frequency.value = current.hz;
  osc.connect(oscGain);

  oscGain.connect(gate);
  noiseGain.connect(gate);
  gate.connect(master);

  osc.start();

  /* gating LFO (square -> waveshaper -> gate.gain) */
  lfo = ctx.createOscillator();
  lfo.type = "square";
  lfo.frequency.value = msToLfoHz(xToMs(x01));

  shaper = ctx.createWaveShaper();
  const N = 1024;
  const curve = new Float32Array(N);
  for (let i=0;i<N;i++){
    const x = (i/(N-1))*2-1;
    curve[i] = x >= 0 ? 1 : 0;
  }
  shaper.curve = curve;
  shaper.oversample = "4x";

  lfoDepth = ctx.createGain();
  lfoDepth.gain.value = 0.0;

  lfo.connect(shaper);
  shaper.connect(lfoDepth);
  lfoDepth.connect(gate.gain);

  lfo.start();
}

function unlockIOSOnce(){
  if (!ctx || iosUnlocked) return;
  try{
    const buffer = ctx.createBuffer(1, 1, ctx.sampleRate);
    const src = ctx.createBufferSource();
    src.buffer = buffer;
    src.connect(ctx.destination);
    src.start(0);
    src.stop(0.01);
    iosUnlocked = true;
  }catch(e){}
}

function ramp(param, value, t=0.02){
  const now = ctx.currentTime;
  param.cancelScheduledValues(now);
  param.setValueAtTime(param.value, now);
  param.linearRampToValueAtTime(value, now + t);
}

function applyXY(){
  const r = pad.getBoundingClientRect();
  dot.style.left = (x01 * r.width) + "px";
  dot.style.top  = (y01 * r.height) + "px";

  if (!ctx || !osc || !lfo) return;

  const mult = yToMult(y01);
  const ms = xToMs(x01);

  const det = 1 + (Math.random()*0.002 - 0.001); // micro drift
  osc.frequency.value = (current.hz * mult) * det;
  lfo.frequency.value = msToLfoHz(ms);
}

/* ------------------ noise buffers (3 types) ------------------ */
function makeWhiteBuffer(seconds=2){
  const len = Math.floor(ctx.sampleRate * seconds);
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i=0;i<len;i++) d[i] = (Math.random()*2 - 1);
  return buf;
}
function makePinkishBuffer(seconds=2){
  const len = Math.floor(ctx.sampleRate * seconds);
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const d = buf.getChannelData(0);
  let y = 0;
  const a = 0.985;
  for (let i=0;i<len;i++){
    const x = (Math.random()*2 - 1);
    y = a*y + (1-a)*x;
    d[i] = y * 1.6;
  }
  return buf;
}
function makeDigitalBuffer(seconds=2){
  const len = Math.floor(ctx.sampleRate * seconds);
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const d = buf.getChannelData(0);
  const holdMin = 6;
  const holdMax = 80;
  let v = 0, n = 0;
  for (let i=0;i<len;i++){
    if (n <= 0){
      v = (Math.random()*2 - 1);
      n = (holdMin + ((Math.random()*(holdMax-holdMin))|0));
    }
    d[i] = v;
    n--;
  }
  return buf;
}

let whiteBuf, pinkBuf, digiBuf;
function ensureNoiseBuffers(){
  if (whiteBuf) return;
  whiteBuf = makeWhiteBuffer(2);
  pinkBuf  = makePinkishBuffer(2);
  digiBuf  = makeDigitalBuffer(2);
}

function startNoise(type){
  ensureNoiseBuffers();
  stopNoise();
  noiseSrc = ctx.createBufferSource();
  noiseSrc.loop = true;
  noiseSrc.buffer = (type===0) ? whiteBuf : (type===1) ? pinkBuf : digiBuf;
  noiseSrc.connect(noiseGain);
  noiseSrc.start();
}
function stopNoise(){
  if (!noiseSrc) return;
  try{ noiseSrc.stop(); }catch(e){}
  try{ noiseSrc.disconnect(); }catch(e){}
  noiseSrc = null;
}

/* ------------------ SF UI beeps (beeper2-ish vibe) ------------------ */
function playGlitchOneShot(type){
  if (!ctx) return;
  const now = ctx.currentTime;

  // output gain (already scaled by glitchBus = BUG_LEVEL)
  const g = ctx.createGain();
  g.gain.setValueAtTime(0.0, now);
  g.connect(glitchBus);

  function cleanup(at){
    g.gain.linearRampToValueAtTime(0.0, at);
    setTimeout(() => {
      try { g.disconnect(); } catch(e){}
    }, Math.max(0, (at - now) * 1000 + 80));
  }

  // click transient (noise tick)
  const click = ctx.createBufferSource();
  const clickBuf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * 0.02), ctx.sampleRate);
  const cd = clickBuf.getChannelData(0);
  for (let i=0;i<cd.length;i++){
    const t = i / cd.length;
    cd[i] = (Math.random()*2-1) * Math.exp(-t*18);
  }
  click.buffer = clickBuf;

  const bp = ctx.createBiquadFilter();
  bp.type = "bandpass";
  bp.frequency.setValueAtTime(2200, now);
  bp.Q.setValueAtTime(10, now);

  const clickGain = ctx.createGain();
  clickGain.gain.setValueAtTime(0.0, now);
  clickGain.gain.linearRampToValueAtTime(0.45, now + 0.001);
  clickGain.gain.exponentialRampToValueAtTime(0.0008, now + 0.018);

  click.connect(bp);
  bp.connect(clickGain);
  clickGain.connect(g);

  // main tone: two-osc stack + subtle FM
  const o1 = ctx.createOscillator();
  const o2 = ctx.createOscillator();
  o1.type = "sine";
  o2.type = "triangle";

  const fm = ctx.createOscillator();
  fm.type = "sine";
  const fmGain = ctx.createGain();
  fmGain.gain.setValueAtTime(0.0, now);

  fm.connect(fmGain);
  fmGain.connect(o1.frequency);

  const toneGain = ctx.createGain();
  toneGain.gain.setValueAtTime(1.0, now);
  toneGain.connect(g);

  o1.connect(toneGain);
  o2.connect(toneGain);

  // master envelope (snappy)
  const A = 0.002, D = 0.060;
  g.gain.linearRampToValueAtTime(1.0, now + A);
  g.gain.exponentialRampToValueAtTime(0.0008, now + A + D);

  const end = now + 0.14;

  // 5 families
  if (type === 0){
    // Up-chirp “pip”
    o1.frequency.setValueAtTime(1800, now);
    o1.frequency.exponentialRampToValueAtTime(8200, now + 0.060);
    o2.frequency.setValueAtTime(1200, now);
    o2.frequency.exponentialRampToValueAtTime(3600, now + 0.060);
    fm.frequency.setValueAtTime(70, now);
    fmGain.gain.setValueAtTime(55, now);
    cleanup(now + 0.080);

  } else if (type === 1){
    // Down-chirp “keen”
    o1.frequency.setValueAtTime(9500, now);
    o1.frequency.exponentialRampToValueAtTime(2600, now + 0.055);
    o2.frequency.setValueAtTime(4800, now);
    o2.frequency.exponentialRampToValueAtTime(1600, now + 0.055);
    fm.frequency.setValueAtTime(55, now);
    fmGain.gain.setValueAtTime(40, now);
    cleanup(now + 0.075);

  } else if (type === 2){
    // Double-beep pulses
    o1.frequency.setValueAtTime(5200, now);
    o2.frequency.setValueAtTime(2600, now);

    toneGain.gain.setValueAtTime(0.0, now);
    toneGain.gain.linearRampToValueAtTime(1.0, now + 0.002);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + 0.028);

    toneGain.gain.setValueAtTime(0.0, now + 0.040);
    toneGain.gain.linearRampToValueAtTime(1.0, now + 0.042);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + 0.070);

    fm.frequency.setValueAtTime(90, now);
    fmGain.gain.setValueAtTime(20, now);
    cleanup(now + 0.090);

  } else if (type === 3){
    // Confirm blip (wobble)
    o1.frequency.setValueAtTime(3400, now);
    o1.frequency.linearRampToValueAtTime(3800, now + 0.018);
    o1.frequency.linearRampToValueAtTime(3300, now + 0.045);

    o2.frequency.setValueAtTime(1700, now);
    o2.frequency.linearRampToValueAtTime(1900, now + 0.018);
    o2.frequency.linearRampToValueAtTime(1650, now + 0.045);

    fm.frequency.setValueAtTime(120, now);
    fmGain.gain.setValueAtTime(35, now);
    cleanup(now + 0.070);

  } else {
    // Scan/error micro-sweep (extra tick)
    bp.frequency.setValueAtTime(2800, now);
    bp.frequency.linearRampToValueAtTime(1400, now + 0.020);

    o1.frequency.setValueAtTime(2400, now);
    o1.frequency.exponentialRampToValueAtTime(7200, now + 0.040);
    o2.frequency.setValueAtTime(900, now);
    o2.frequency.exponentialRampToValueAtTime(2100, now + 0.040);

    fm.frequency.setValueAtTime(45, now);
    fmGain.gain.setValueAtTime(75, now);
    cleanup(now + 0.085);
  }

  // start/stop
  click.start(now);
  fm.start(now);
  o1.start(now);
  o2.start(now);

  setTimeout(() => {
    try { click.stop(); } catch(e){}
    try { fm.stop(); } catch(e){}
    try { o1.stop(); } catch(e){}
    try { o2.stop(); } catch(e){}
    try { click.disconnect(); } catch(e){}
    try { bp.disconnect(); } catch(e){}
    try { clickGain.disconnect(); } catch(e){}
    try { fmGain.disconnect(); } catch(e){}
    try { toneGain.disconnect(); } catch(e){}
  }, Math.max(0, (end - now) * 1000 + 90));
}

/* ------------------ start/stop + pointer ------------------ */
function startAudioGesture(){
  ensureAudio();
  unlockIOSOnce();

  ctx.resume().then(() => {
    if (ctx.state !== "running") return;

    holding = true;
    dot.classList.remove("off");

    current = pickRandomNote();

    // random SF beep one-shot
    if (Math.random() < GLITCH_PROB){
      playGlitchOneShot((Math.random()*5)|0);
    }

    // random noise “bug” while held
    const bugMode = (Math.random() < NOISE_PROB);
    const bugType = (Math.random()*3)|0;

    if (bugMode){
      startNoise(bugType);
      ramp(oscGain.gain, 0.0, 0.02);
      ramp(noiseGain.gain, BUG_LEVEL, 0.02);
    } else {
      stopNoise();
      ramp(noiseGain.gain, 0.0, 0.02);
      ramp(oscGain.gain, 1.0, 0.02);
    }

    applyXY();

    ramp(lfoDepth.gain, 1.0, 0.02);
    ramp(master.gain, MASTER_LEVEL, 0.02);
  }).catch(()=>{});
}

function stop(){
  holding = false;
  dot.classList.add("off");
  if (!ctx) return;

  ramp(lfoDepth.gain, 0.0, 0.03);
  ramp(master.gain, 0.0, 0.05);

  setTimeout(() => {
    if (!holding) stopNoise();
  }, 140);
}

function updateFromClientXY(clientX, clientY){
  const r = pad.getBoundingClientRect();
  x01 = clamp01((clientX - r.left) / r.width);
  y01 = clamp01((clientY - r.top) / r.height);
  applyXY();
}

let pid = null;

hit.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  pid = e.pointerId;
  try { hit.setPointerCapture(pid); } catch(_){}
  updateFromClientXY(e.clientX, e.clientY);
  startAudioGesture();
}, {passive:false});

hit.addEventListener("pointermove", (e) => {
  if (!holding) return;
  if (pid !== null && e.pointerId !== pid) return;
  e.preventDefault();
  updateFromClientXY(e.clientX, e.clientY);
}, {passive:false});

hit.addEventListener("pointerup", (e) => {
  if (pid !== null && e.pointerId !== pid) return;
  e.preventDefault();
  pid = null;
  stop();
}, {passive:false});

hit.addEventListener("pointercancel", (e) => {
  e.preventDefault();
  pid = null;
  stop();
}, {passive:false});

/* iOS Safari sometimes prefers touch events too */
hit.addEventListener("touchstart", (e) => {
  e.preventDefault();
  const t = e.touches[0];
  if (!t) return;
  updateFromClientXY(t.clientX, t.clientY);
  startAudioGesture();
}, {passive:false});

hit.addEventListener("touchmove", (e) => {
  if (!holding) return;
  e.preventDefault();
  const t = e.touches[0];
  if (!t) return;
  updateFromClientXY(t.clientX, t.clientY);
}, {passive:false});

hit.addEventListener("touchend", (e) => { e.preventDefault(); stop(); }, {passive:false});
hit.addEventListener("touchcancel", (e) => { e.preventDefault(); stop(); }, {passive:false});

window.addEventListener("blur", stop);
document.addEventListener("visibilitychange", () => { if (document.hidden) stop(); });

applyXY();
</script>
</body>
</html>
