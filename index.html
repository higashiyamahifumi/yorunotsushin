<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>yoru no tsushin</title>

  <!-- Thin sci-fi font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@200;300;400&display=swap" rel="stylesheet">

  <style>
    :root{
      --blue:#1348ff;
      --blue2:#0b2ea7;
      --ink:#0a0d14;
      --paper:#b9bcc4;        /* matte gray */
      --paper2:#aeb2bc;
      --line: rgba(19,72,255,.85);
      --lineSoft: rgba(19,72,255,.22);
      --shadow: rgba(0,0,0,.35);
      --white: rgba(255,255,255,.92);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:
        radial-gradient(1200px 700px at 30% 20%, rgba(19,72,255,.10), transparent 60%),
        radial-gradient(1000px 650px at 70% 90%, rgba(19,72,255,.08), transparent 62%),
        linear-gradient(180deg, #070a10 0%, #05070c 100%);
      color: var(--white);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      overscroll-behavior:none;
    }

    .wrap{
      width:min(980px, 96vw);
      padding:18px;
    }

    .frame{
      position:relative;
      border:1px solid rgba(19,72,255,.35);
      border-radius:14px;
      overflow:hidden;
      box-shadow: 0 22px 70px rgba(0,0,0,.55);
      background:
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.22)),
        linear-gradient(90deg, rgba(0,0,0,.20), transparent 40%, rgba(0,0,0,.28));
    }

    /* outer grid like reference */
    .frame::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        repeating-linear-gradient(0deg,  rgba(19,72,255,.18) 0 1px, transparent 1px 70px),
        repeating-linear-gradient(90deg, rgba(19,72,255,.18) 0 1px, transparent 1px 120px);
      opacity:.65;
      pointer-events:none;
      mix-blend-mode: screen;
    }

    /* big abstract typographic slab (no numbers) */
    .frame::after{
      content:"/n/";
      position:absolute;
      left:-40px;
      bottom:-120px;
      font-family: "Oxanium", ui-monospace, monospace;
      font-weight:300;
      letter-spacing:-8px;
      font-size:min(46vw, 560px);
      color: rgba(19,72,255,.55);
      transform: skewX(-10deg);
      pointer-events:none;
      opacity:.22;
      filter: blur(.2px);
    }

    .topbar{
      position:relative;
      display:flex;
      align-items:center;
      gap:12px;
      padding:14px 16px;
      border-bottom:2px solid rgba(19,72,255,.65);
      background:
        linear-gradient(180deg, rgba(185,188,196,.10), rgba(0,0,0,.15));
    }

    .title{
      font-family:"Oxanium", ui-monospace, monospace;
      font-weight:200;
      letter-spacing:4px;
      text-transform: lowercase;
      font-size:14px;
      color: rgba(255,255,255,.92);
      user-select:none;
      -webkit-user-select:none;
    }

    /* tiny indicator bars (no digits) */
    .indicators{
      margin-left:auto;
      display:flex;
      gap:6px;
      opacity:.8;
    }
    .bar{
      width:16px;
      height:2px;
      background: rgba(19,72,255,.75);
      box-shadow: 0 0 10px rgba(19,72,255,.12);
    }
    .bar.dim{ opacity:.35; }

    .gridArea{
      display:grid;
      grid-template-columns: 1.15fr 0.85fr;
      gap:0;
      background: transparent;
    }

    /* left big panel */
    .left{
      position:relative;
      padding:14px;
      border-right:2px solid rgba(19,72,255,.65);
      background:
        linear-gradient(180deg, rgba(185,188,196,.08), rgba(0,0,0,.22));
    }

    /* right stacked panels like DIV blocks */
    .right{
      display:grid;
      grid-template-rows: 1fr 1fr;
    }
    .cell{
      position:relative;
      padding:12px;
      border-bottom:2px solid rgba(19,72,255,.65);
      background:
        linear-gradient(180deg, rgba(185,188,196,.06), rgba(0,0,0,.20));
    }
    .cell:last-child{ border-bottom:none; }

    /* ascii texture (no numbers) */
    .ascii{
      position:absolute;
      inset:10px 10px auto 10px;
      height:120px;
      overflow:hidden;
      opacity:.22;
      color: rgba(255,255,255,.85);
      font-size:12px;
      line-height:12px;
      white-space:pre;
      pointer-events:none;
      filter: blur(.15px);
    }
    .ascii.bottom{
      inset:auto 10px 10px 10px;
      height:110px;
      opacity:.16;
    }

    /* XY pad */
    .padPlate{
      width:100%;
      height:min(62vh, 560px);
      border-radius:12px;
      background:
        linear-gradient(180deg, rgba(185,188,196,.90), rgba(174,178,188,.88));
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.35),
        inset 0 -1px 0 rgba(0,0,0,.18),
        0 20px 60px rgba(0,0,0,.28);
      border:2px solid rgba(19,72,255,.85);
      position:relative;
      overflow:hidden;
      touch-action:none;
      -webkit-tap-highlight-color: transparent;
    }

    /* inner grid + div lines */
    .padPlate::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        repeating-linear-gradient(0deg,  rgba(19,72,255,.22) 0 1px, transparent 1px 40px),
        repeating-linear-gradient(90deg, rgba(19,72,255,.22) 0 1px, transparent 1px 64px);
      opacity:.95;
      pointer-events:none;
    }
    .padPlate::after{
      content:"";
      position:absolute;
      inset:0;
      background:
        linear-gradient(0deg, transparent 49.5%, rgba(19,72,255,.45) 50%, transparent 50.5%),
        linear-gradient(90deg, transparent 49.5%, rgba(19,72,255,.45) 50%, transparent 50.5%);
      pointer-events:none;
      opacity:.55;
    }

    /* cursor dot */
    .dot{
      position:absolute;
      width:12px; height:12px;
      border-radius:999px;
      background: rgba(19,72,255,.92);
      box-shadow: 0 0 14px rgba(19,72,255,.25);
      border:1px solid rgba(255,255,255,.35);
      transform: translate(-50%,-50%);
      pointer-events:none;
      opacity:.95;
    }
    .dot.off{
      opacity:.30;
      background: rgba(19,72,255,.35);
      box-shadow:none;
    }

    .padHit{
      position:absolute;
      inset:0;
      display:block;
      background: transparent;
      touch-action:none;
      -webkit-tap-highlight-color: transparent;
    }

    /* subtle caption (no numbers) */
    .tag{
      position:absolute;
      right:12px;
      top:12px;
      font-family:"Oxanium", ui-monospace, monospace;
      font-weight:200;
      letter-spacing:3px;
      font-size:11px;
      color: rgba(0,0,0,.35);
      mix-blend-mode:multiply;
      user-select:none;
      -webkit-user-select:none;
      pointer-events:none;
    }

    /* mobile spacing */
    @media (max-width: 860px){
      .gridArea{ grid-template-columns: 1fr; }
      .left{ border-right:none; border-bottom:2px solid rgba(19,72,255,.65); }
      .padPlate{ height:min(68vh, 600px); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="frame">
      <div class="topbar">
        <div class="title">yoru no tsushin</div>
        <div class="indicators" aria-hidden="true">
          <div class="bar"></div>
          <div class="bar dim"></div>
          <div class="bar dim"></div>
        </div>
      </div>

      <div class="gridArea">
        <div class="left">
          <div class="ascii" aria-hidden="true">
/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
|  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  |
|   \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   |
|----\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
|    | | | | | | | | | | | | | | | | | | | | | | | |    |
\_______________________________________________________/
          </div>

          <div class="padPlate" id="pad">
            <div class="tag" aria-hidden="true">transceiver</div>
            <div class="dot off" id="dot"></div>
            <div class="padHit" id="hit" aria-label="XY pad"></div>
          </div>

          <div class="ascii bottom" aria-hidden="true">
|/////|\\\\\|/////|\\\\\|/////|\\\\\|/////|\\\\\|/////|
|_____|_____|_____|_____|_____|_____|_____|_____|_____|
|  / / / / / / / / / / / / / / / / / / / / / / / /   |
|_/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/___|
          </div>
        </div>

        <div class="right">
          <div class="cell">
            <div class="ascii" aria-hidden="true">
|-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\|
|  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||     |
|_/__\_/__\_/__\_/__\_/__\_/__\_/__\_/__\_/__\_/__\____|
            </div>
          </div>
          <div class="cell">
            <div class="ascii bottom" aria-hidden="true">
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
/_/ /_/ /_/ /_/ /_/ /_/ /_/ /_/ /_/ /_/ /_/ /_/ /_/ /_/
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/*
  Mapping:
  - Y (up/down)  = pitch (top high, bottom low)
  - X (left/right) = interval speed (RIGHT fast, LEFT slow)

  Normal:
  - On press: random pick from Fmaj7(9): F A C E G
  - Busy-tone gating by LFO (square -> shaper -> gate.gain)

  Bug A (noise):
  - About 1/15 chance per press to switch to NOISE mode while held
  - 3 noise types; volume 20%

  Bug B (pip/keen):
  - About 1/12 chance per press to fire ONE-SHOT glitch beep (5 types)
  - Sine-only; volume 20%
*/

let ctx, master, gate;
let osc, oscGain;
let lfo, shaper, lfoDepth;

let noiseGain;
let noiseSrc = null;
let iosUnlocked = false;

let glitchBus;

const pad = document.getElementById("pad");
const hit = document.getElementById("hit");
const dot = document.getElementById("dot");

const MIN_MS = 160;
const MAX_MS = 900;

/* main held volume */
const MASTER_LEVEL = 0.096;

/* bug volume (noise + pip) */
const BUG_LEVEL = 0.20;

/* probabilities */
const NOISE_PROB  = 1/15;
const GLITCH_PROB = 1/12;

/* Fmaj7(9): F A C E G */
const MID = [
  { hz: 349.228 }, // F
  { hz: 440.000 }, // A
  { hz: 523.251 }, // C
  { hz: 659.255 }, // E
  { hz: 783.991 }, // G
];

let current = MID[0];
let x01 = 0.5;
let y01 = 0.5;
let holding = false;

let bugMode = false;
let bugType = 0;

function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function pickRandomNote(){ return MID[(Math.random() * MID.length) | 0]; }

/* Y = pitch : top high, bottom low (mult 0.5..2.0) */
function yToMult(y){
  return 2.0 - 1.5 * y;
}

/* X = interval : right fast, left slow */
function xToMs(x){
  return MAX_MS - (MAX_MS - MIN_MS) * x;
}

/* gate LFO frequency: ON=ms, OFF=ms => full period=2ms => freq=500/ms */
function msToLfoHz(ms){ return 500 / ms; }

function ensureAudio(){
  if (ctx) return;
  ctx = new (window.AudioContext || window.webkitAudioContext)();

  master = ctx.createGain();
  master.gain.value = 0.0;
  master.connect(ctx.destination);

  gate = ctx.createGain();
  gate.gain.value = 0.0;

  oscGain = ctx.createGain();
  oscGain.gain.value = 1.0;

  noiseGain = ctx.createGain();
  noiseGain.gain.value = 0.0;

  glitchBus = ctx.createGain();
  glitchBus.gain.value = BUG_LEVEL; // 20%
  glitchBus.connect(master);

  osc = ctx.createOscillator();
  osc.type = "sine";
  osc.frequency.value = current.hz;
  osc.connect(oscGain);

  // mix -> gate -> master
  oscGain.connect(gate);
  noiseGain.connect(gate);
  gate.connect(master);

  osc.start();

  // LFO gate (stable on mobile)
  lfo = ctx.createOscillator();
  lfo.type = "square";
  lfo.frequency.value = msToLfoHz(xToMs(x01));

  shaper = ctx.createWaveShaper();
  const N = 1024;
  const curve = new Float32Array(N);
  for (let i=0;i<N;i++){
    const x = (i/(N-1))*2-1;
    curve[i] = x >= 0 ? 1 : 0;
  }
  shaper.curve = curve;
  shaper.oversample = "4x";

  lfoDepth = ctx.createGain();
  lfoDepth.gain.value = 0.0;

  lfo.connect(shaper);
  shaper.connect(lfoDepth);
  lfoDepth.connect(gate.gain);

  lfo.start();
}

function unlockIOSOnce(){
  if (!ctx || iosUnlocked) return;
  try{
    const buffer = ctx.createBuffer(1, 1, ctx.sampleRate);
    const src = ctx.createBufferSource();
    src.buffer = buffer;
    src.connect(ctx.destination);
    src.start(0);
    src.stop(0.01);
    iosUnlocked = true;
  }catch(e){}
}

function ramp(param, value, t=0.02){
  const now = ctx.currentTime;
  param.cancelScheduledValues(now);
  param.setValueAtTime(param.value, now);
  param.linearRampToValueAtTime(value, now + t);
}

function applyXY(){
  const r = pad.getBoundingClientRect();
  dot.style.left = (x01 * r.width) + "px";
  dot.style.top  = (y01 * r.height) + "px";

  if (!ctx || !osc || !lfo) return;

  const mult = yToMult(y01);
  const ms = xToMs(x01);

  const det = 1 + (Math.random()*0.002 - 0.001);
  osc.frequency.value = (current.hz * mult) * det;
  lfo.frequency.value = msToLfoHz(ms);
}

/* ---------- Noise generators (3 types) ---------- */
function makeWhiteBuffer(seconds=2){
  const len = Math.floor(ctx.sampleRate * seconds);
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i=0;i<len;i++) d[i] = (Math.random()*2 - 1);
  return buf;
}

function makePinkishBuffer(seconds=2){
  const len = Math.floor(ctx.sampleRate * seconds);
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const d = buf.getChannelData(0);
  let y = 0;
  const a = 0.985;
  for (let i=0;i<len;i++){
    const x = (Math.random()*2 - 1);
    y = a*y + (1-a)*x;
    d[i] = y * 1.6;
  }
  return buf;
}

function makeDigitalBuffer(seconds=2){
  const len = Math.floor(ctx.sampleRate * seconds);
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const d = buf.getChannelData(0);
  const holdMin = 6;
  const holdMax = 80;
  let v = 0, n = 0;
  for (let i=0;i<len;i++){
    if (n <= 0){
      v = (Math.random()*2 - 1);
      n = (holdMin + ((Math.random()*(holdMax-holdMin))|0));
    }
    d[i] = v;
    n--;
  }
  return buf;
}

let whiteBuf, pinkBuf, digiBuf;

function ensureNoiseBuffers(){
  if (whiteBuf) return;
  whiteBuf = makeWhiteBuffer(2);
  pinkBuf  = makePinkishBuffer(2);
  digiBuf  = makeDigitalBuffer(2);
}

function startNoise(type){
  ensureNoiseBuffers();
  stopNoise();

  noiseSrc = ctx.createBufferSource();
  noiseSrc.loop = true;
  noiseSrc.buffer = (type===0) ? whiteBuf : (type===1) ? pinkBuf : digiBuf;
  noiseSrc.connect(noiseGain);
  noiseSrc.start();
}

function stopNoise(){
  if (!noiseSrc) return;
  try{ noiseSrc.stop(); }catch(e){}
  try{ noiseSrc.disconnect(); }catch(e){}
  noiseSrc = null;
}

/* ---------- Glitch one-shots (5 types, SINE ONLY) ---------- */
function playGlitchOneShot(type){
  if (!ctx) return;

  const now = ctx.currentTime;

  const g = ctx.createGain();
  g.gain.setValueAtTime(0.0, now);
  g.connect(glitchBus);

  const o = ctx.createOscillator();
  o.type = "sine";
  o.connect(g);

  function stopAt(tEnd){
    g.gain.linearRampToValueAtTime(0.0, tEnd);
    setTimeout(() => {
      try{ o.stop(); }catch(e){}
      try{ o.disconnect(); }catch(e){}
      try{ g.disconnect(); }catch(e){}
    }, Math.max(0, (tEnd - now) * 1000 + 50));
  }

  if (type === 0){
    // tiny pip
    o.frequency.setValueAtTime(6200, now);
    o.start(now);
    g.gain.linearRampToValueAtTime(1.0, now + 0.0015);
    stopAt(now + 0.030);
    return;
  }

  if (type === 1){
    // longer keen
    o.frequency.setValueAtTime(3800, now);
    o.start(now);
    g.gain.linearRampToValueAtTime(1.0, now + 0.0015);
    stopAt(now + 0.070);
    return;
  }

  if (type === 2){
    // upward chirp
    o.frequency.setValueAtTime(1800, now);
    o.frequency.exponentialRampToValueAtTime(9200, now + 0.055);
    o.start(now);
    g.gain.linearRampToValueAtTime(1.0, now + 0.0015);
    stopAt(now + 0.070);
    return;
  }

  if (type === 3){
    // downward chirp
    o.frequency.setValueAtTime(9400, now);
    o.frequency.exponentialRampToValueAtTime(2200, now + 0.050);
    o.start(now);
    g.gain.linearRampToValueAtTime(1.0, now + 0.0015);
    stopAt(now + 0.065);
    return;
  }

  // type === 4 : double blip
  o.frequency.setValueAtTime(5400, now);
  o.start(now);

  g.gain.linearRampToValueAtTime(1.0, now + 0.0015);
  g.gain.linearRampToValueAtTime(0.0, now + 0.020);

  g.gain.setValueAtTime(0.0, now + 0.028);
  g.gain.linearRampToValueAtTime(1.0, now + 0.030);
  g.gain.linearRampToValueAtTime(0.0, now + 0.050);

  stopAt(now + 0.055);
}

/* ---------- start/stop ---------- */
function startAudioGesture(){
  ensureAudio();
  unlockIOSOnce();

  ctx.resume().then(() => {
    if (ctx.state !== "running") return;

    holding = true;
    dot.classList.remove("off");

    current = pickRandomNote();

    // BUG B: 1/12 chance on press → one-shot pip/keen
    if (Math.random() < GLITCH_PROB){
      const t = (Math.random()*5)|0;
      playGlitchOneShot(t);
    }

    // BUG A: 1/15 chance → noise mode while held
    bugMode = (Math.random() < NOISE_PROB);
    bugType = (Math.random()*3)|0;

    if (bugMode){
      startNoise(bugType);
      ramp(oscGain.gain, 0.0, 0.02);
      ramp(noiseGain.gain, BUG_LEVEL, 0.02); // 20%
    } else {
      stopNoise();
      ramp(noiseGain.gain, 0.0, 0.02);
      ramp(oscGain.gain, 1.0, 0.02);
    }

    applyXY();

    ramp(lfoDepth.gain, 1.0, 0.02);
    ramp(master.gain, MASTER_LEVEL, 0.02);
  }).catch(()=>{});
}

function stop(){
  holding = false;
  dot.classList.add("off");
  if (!ctx) return;

  ramp(lfoDepth.gain, 0.0, 0.03);
  ramp(master.gain, 0.0, 0.05);

  setTimeout(() => {
    if (!holding) stopNoise();
  }, 140);
}

function updateFromClientXY(clientX, clientY){
  const r = pad.getBoundingClientRect();
  x01 = clamp01((clientX - r.left) / r.width);
  y01 = clamp01((clientY - r.top) / r.height);
  applyXY();
}

/* pointer + touch */
let pid = null;

hit.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  pid = e.pointerId;
  try { hit.setPointerCapture(pid); } catch(_){}
  updateFromClientXY(e.clientX, e.clientY);
  startAudioGesture();
}, {passive:false});

hit.addEventListener("pointermove", (e) => {
  if (!holding) return;
  if (pid !== null && e.pointerId !== pid) return;
  e.preventDefault();
  updateFromClientXY(e.clientX, e.clientY);
}, {passive:false});

hit.addEventListener("pointerup", (e) => {
  if (pid !== null && e.pointerId !== pid) return;
  e.preventDefault();
  pid = null;
  stop();
}, {passive:false});

hit.addEventListener("pointercancel", (e) => {
  e.preventDefault();
  pid = null;
  stop();
}, {passive:false});

hit.addEventListener("touchstart", (e) => {
  e.preventDefault();
  const t = e.touches[0];
  if (!t) return;
  updateFromClientXY(t.clientX, t.clientY);
  startAudioGesture();
}, {passive:false});

hit.addEventListener("touchmove", (e) => {
  if (!holding) return;
  e.preventDefault();
  const t = e.touches[0];
  if (!t) return;
  updateFromClientXY(t.clientX, t.clientY);
}, {passive:false});

hit.addEventListener("touchend", (e) => { e.preventDefault(); stop(); }, {passive:false});
hit.addEventListener("touchcancel", (e) => { e.preventDefault(); stop(); }, {passive:false});

window.addEventListener("blur", stop);
document.addEventListener("visibilitychange", () => { if (document.hidden) stop(); });

applyXY();
</script>
</body>
</html>
